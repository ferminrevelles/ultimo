{"version":3,"sources":["/media/ermaestrox/BACKUP/Carpeta Docente/Master Desarrollo de Sitios y APP Web/Desarrollo front-end (Avanzado)/PEC5/Entregar/Ejercicio4c/node_modules/@ngrx/effects/fesm2015/effects.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;AAmBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8VC,oFAGC;;;;;;;;;;kCAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4ND,sGAGC;;;;;;;;;;;kCAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6ED,sGAGC;;;;;;;;+FAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuDD,+YAGC;;;;;;;;;;;;;;;;;;;;;;;;;;kCAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgCD,uTAGC;;;;;;;;;;;;;;;;;;kCAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuDD;;;;0BAGC","file":"effects.js","sourcesContent":["/**\n * @license NgRx 9.0.0\n * (c) 2015-2018 Brandon Roberts, Mike Ryan, Rob Wormald, Victor Savkin\n * License: MIT\n */\nimport { compose, ScannedActionsSubject, Store, createAction, StoreRootModule, StoreFeatureModule } from '@ngrx/store';\nimport { merge, Observable, Subject, defer, Notification } from 'rxjs';\nimport { ignoreElements, materialize, map, catchError, filter, groupBy, mergeMap, exhaustMap, dematerialize, take, concatMap, finalize } from 'rxjs/operators';\nimport { Injectable, Inject, InjectionToken, ErrorHandler, NgModule, Optional, SkipSelf } from '@angular/core';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/effects/src/models.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Configures an effect created by `createEffect`.\n * @record\n */\nfunction EffectConfig() { }\nif (false) {\n    /**\n     * Determines if the action emitted by the effect is dispatched to the store.\n     * If false, effect does not need to return type `Observable<Action>`.\n     * @type {?|undefined}\n     */\n    EffectConfig.prototype.dispatch;\n    /**\n     * Determines if the effect will be resubscribed to if an error occurs in the main actions stream.\n     * @type {?|undefined}\n     */\n    EffectConfig.prototype.useEffectsErrorHandler;\n}\n/** @type {?} */\nconst DEFAULT_EFFECT_CONFIG = {\n    dispatch: true,\n    useEffectsErrorHandler: true,\n};\n/** @type {?} */\nconst CREATE_EFFECT_METADATA_KEY = '__@ngrx/effects_create__';\n/**\n * @record\n */\nfunction CreateEffectMetadata() { }\nif (false) {\n    /* Skipping unnamed member:\n    [CREATE_EFFECT_METADATA_KEY]: EffectConfig;*/\n}\n/**\n * @record\n * @template T\n */\nfunction EffectMetadata() { }\nif (false) {\n    /** @type {?} */\n    EffectMetadata.prototype.propertyName;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/effects/src/effect_creator.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * \\@description\n * Creates an effect from an `Observable` and an `EffectConfig`.\n *\n * \\@usageNotes\n *\n * ** Mapping to a different action **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     map(() => FeatureActions.actionTwo())\n *   )\n * );\n * ```\n *\n *  ** Non-dispatching effects **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     tap(() => console.log('Action One Dispatched'))\n *   ),\n *   { dispatch: false }\n *   // FeatureActions.actionOne is not dispatched\n * );\n * ```\n * @template C, DT, OT, R\n * @param {?} source A function which returns an `Observable`.\n * @param {?=} config A `Partial<EffectConfig>` to configure the effect.  By default, `dispatch` is true and `useEffectsErrorHandler` is true.\n * @return {?} If `EffectConfig`#`dispatch` is true, returns `Observable<Action>`.  Else, returns `Observable<unknown>`.\n *\n */\nfunction createEffect(source, config) {\n    /** @type {?} */\n    const effect = source();\n    /** @type {?} */\n    const value = Object.assign(Object.assign({}, DEFAULT_EFFECT_CONFIG), config);\n    Object.defineProperty(effect, CREATE_EFFECT_METADATA_KEY, {\n        value,\n    });\n    return (/** @type {?} */ (effect));\n}\n/**\n * @template T\n * @param {?} instance\n * @return {?}\n */\nfunction getCreateEffectMetadata(instance) {\n    /** @type {?} */\n    const propertyNames = (/** @type {?} */ (Object.getOwnPropertyNames(instance)));\n    /** @type {?} */\n    const metadata = propertyNames\n        .filter((/**\n     * @param {?} propertyName\n     * @return {?}\n     */\n    propertyName => instance[propertyName] &&\n        instance[propertyName].hasOwnProperty(CREATE_EFFECT_METADATA_KEY)))\n        .map((/**\n     * @param {?} propertyName\n     * @return {?}\n     */\n    propertyName => {\n        /** @type {?} */\n        const metaData = ((/** @type {?} */ (instance[propertyName])))[CREATE_EFFECT_METADATA_KEY];\n        return Object.assign({ propertyName }, metaData);\n    }));\n    return metadata;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/effects/src/utils.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @template T\n * @param {?} instance\n * @return {?}\n */\nfunction getSourceForInstance(instance) {\n    return Object.getPrototypeOf(instance);\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/effects/src/effect_decorator.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst METADATA_KEY = '__@ngrx/effects__';\n/**\n * @param {?=} config\n * @return {?}\n */\nfunction Effect(config = {}) {\n    return (/**\n     * @template T, K\n     * @param {?} target\n     * @param {?} propertyName\n     * @return {?}\n     */\n    function (target, propertyName) {\n        /** @type {?} */\n        const metadata = Object.assign(Object.assign(Object.assign({}, DEFAULT_EFFECT_CONFIG), config), { // Overrides any defaults if values are provided\n            propertyName });\n        addEffectMetadataEntry(target, metadata);\n    });\n}\n/**\n * @template T\n * @param {?} instance\n * @return {?}\n */\nfunction getEffectDecoratorMetadata(instance) {\n    /** @type {?} */\n    const effectsDecorators = compose(getEffectMetadataEntries, getSourceForInstance)(instance);\n    return effectsDecorators;\n}\n/**\n * Type guard to detemine whether METADATA_KEY is already present on the Class\n * constructor\n * @template T\n * @param {?} sourceProto\n * @return {?}\n */\nfunction hasMetadataEntries(sourceProto) {\n    return sourceProto.constructor.hasOwnProperty(METADATA_KEY);\n}\n/**\n * Add Effect Metadata to the Effect Class constructor under specific key\n * @template T\n * @param {?} sourceProto\n * @param {?} metadata\n * @return {?}\n */\nfunction addEffectMetadataEntry(sourceProto, metadata) {\n    if (hasMetadataEntries(sourceProto)) {\n        sourceProto.constructor[METADATA_KEY].push(metadata);\n    }\n    else {\n        Object.defineProperty(sourceProto.constructor, METADATA_KEY, {\n            value: [metadata],\n        });\n    }\n}\n/**\n * @template T\n * @param {?} sourceProto\n * @return {?}\n */\nfunction getEffectMetadataEntries(sourceProto) {\n    return hasMetadataEntries(sourceProto)\n        ? sourceProto.constructor[METADATA_KEY]\n        : [];\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/effects/src/effects_metadata.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @template T\n * @param {?} instance\n * @return {?}\n */\nfunction getEffectsMetadata(instance) {\n    return getSourceMetadata(instance).reduce((/**\n     * @param {?} acc\n     * @param {?} __1\n     * @return {?}\n     */\n    (acc, { propertyName, dispatch, useEffectsErrorHandler }) => {\n        acc[propertyName] = { dispatch, useEffectsErrorHandler };\n        return acc;\n    }), {});\n}\n/**\n * @template T\n * @param {?} instance\n * @return {?}\n */\nfunction getSourceMetadata(instance) {\n    /** @type {?} */\n    const effects = [\n        getEffectDecoratorMetadata,\n        getCreateEffectMetadata,\n    ];\n    return effects.reduce((/**\n     * @param {?} sources\n     * @param {?} source\n     * @return {?}\n     */\n    (sources, source) => sources.concat(source(instance))), []);\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/effects/src/effects_resolver.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} sourceInstance\n * @param {?} globalErrorHandler\n * @param {?} effectsErrorHandler\n * @return {?}\n */\nfunction mergeEffects(sourceInstance, globalErrorHandler, effectsErrorHandler) {\n    /** @type {?} */\n    const sourceName = getSourceForInstance(sourceInstance).constructor.name;\n    /** @type {?} */\n    const observables$ = getSourceMetadata(sourceInstance).map((/**\n     * @param {?} __0\n     * @return {?}\n     */\n    ({ propertyName, dispatch, useEffectsErrorHandler, }) => {\n        /** @type {?} */\n        const observable$ = typeof sourceInstance[propertyName] === 'function'\n            ? sourceInstance[propertyName]()\n            : sourceInstance[propertyName];\n        /** @type {?} */\n        const effectAction$ = useEffectsErrorHandler\n            ? effectsErrorHandler(observable$, globalErrorHandler)\n            : observable$;\n        if (dispatch === false) {\n            return effectAction$.pipe(ignoreElements());\n        }\n        /** @type {?} */\n        const materialized$ = effectAction$.pipe(materialize());\n        return materialized$.pipe(map((/**\n         * @param {?} notification\n         * @return {?}\n         */\n        (notification) => ({\n            effect: sourceInstance[propertyName],\n            notification,\n            propertyName,\n            sourceName,\n            sourceInstance,\n        }))));\n    }));\n    return merge(...observables$);\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/effects/src/effects_error_handler.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst MAX_NUMBER_OF_RETRY_ATTEMPTS = 10;\n/**\n * @template T\n * @param {?} observable$\n * @param {?} errorHandler\n * @param {?=} retryAttemptLeft\n * @return {?}\n */\nfunction defaultEffectsErrorHandler(observable$, errorHandler, retryAttemptLeft = MAX_NUMBER_OF_RETRY_ATTEMPTS) {\n    return observable$.pipe(catchError((/**\n     * @param {?} error\n     * @return {?}\n     */\n    error => {\n        if (errorHandler)\n            errorHandler.handleError(error);\n        if (retryAttemptLeft <= 1) {\n            return observable$; // last attempt\n        }\n        // Return observable that produces this particular effect\n        return defaultEffectsErrorHandler(observable$, errorHandler, retryAttemptLeft - 1);\n    })));\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/effects/src/actions.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @template V\n */\nclass Actions extends Observable {\n    /**\n     * @param {?=} source\n     */\n    constructor(source) {\n        super();\n        if (source) {\n            this.source = source;\n        }\n    }\n    /**\n     * @template R\n     * @param {?} operator\n     * @return {?}\n     */\n    lift(operator) {\n        /** @type {?} */\n        const observable = new Actions();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    }\n}\nActions.decorators = [\n    { type: Injectable }\n];\n/** @nocollapse */\nActions.ctorParameters = () => [\n    { type: Observable, decorators: [{ type: Inject, args: [ScannedActionsSubject,] }] }\n];\n/**\n * @param {...?} allowedTypes\n * @return {?}\n */\nfunction ofType(...allowedTypes) {\n    return filter((/**\n     * @param {?} action\n     * @return {?}\n     */\n    (action) => allowedTypes.some((/**\n     * @param {?} typeOrActionCreator\n     * @return {?}\n     */\n    typeOrActionCreator => {\n        if (typeof typeOrActionCreator === 'string') {\n            // Comparing the string to type\n            return typeOrActionCreator === action.type;\n        }\n        // We are filtering by ActionCreator\n        return typeOrActionCreator.type === action.type;\n    }))));\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/effects/src/effect_notification.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @record\n */\nfunction EffectNotification() { }\nif (false) {\n    /** @type {?} */\n    EffectNotification.prototype.effect;\n    /** @type {?} */\n    EffectNotification.prototype.propertyName;\n    /** @type {?} */\n    EffectNotification.prototype.sourceName;\n    /** @type {?} */\n    EffectNotification.prototype.sourceInstance;\n    /** @type {?} */\n    EffectNotification.prototype.notification;\n}\n/**\n * @param {?} output\n * @param {?} reporter\n * @return {?}\n */\nfunction reportInvalidActions(output, reporter) {\n    if (output.notification.kind === 'N') {\n        /** @type {?} */\n        const action = output.notification.value;\n        /** @type {?} */\n        const isInvalidAction = !isAction(action);\n        if (isInvalidAction) {\n            reporter.handleError(new Error(`Effect ${getEffectName(output)} dispatched an invalid action: ${stringify(action)}`));\n        }\n    }\n}\n/**\n * @param {?} action\n * @return {?}\n */\nfunction isAction(action) {\n    return (typeof action !== 'function' &&\n        action &&\n        action.type &&\n        typeof action.type === 'string');\n}\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction getEffectName({ propertyName, sourceInstance, sourceName, }) {\n    /** @type {?} */\n    const isMethod = typeof sourceInstance[propertyName] === 'function';\n    return `\"${sourceName}.${String(propertyName)}${isMethod ? '()' : ''}\"`;\n}\n/**\n * @param {?} action\n * @return {?}\n */\nfunction stringify(action) {\n    try {\n        return JSON.stringify(action);\n    }\n    catch (_a) {\n        return action;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/effects/src/lifecycle_hooks.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst onIdentifyEffectsKey = 'ngrxOnIdentifyEffects';\n/**\n * @param {?} instance\n * @return {?}\n */\nfunction isOnIdentifyEffects(instance) {\n    return isFunction(instance, onIdentifyEffectsKey);\n}\n/** @type {?} */\nconst onRunEffectsKey = 'ngrxOnRunEffects';\n/**\n * @param {?} instance\n * @return {?}\n */\nfunction isOnRunEffects(instance) {\n    return isFunction(instance, onRunEffectsKey);\n}\n/** @type {?} */\nconst onInitEffects = 'ngrxOnInitEffects';\n/**\n * @param {?} instance\n * @return {?}\n */\nfunction isOnInitEffects(instance) {\n    return isFunction(instance, onInitEffects);\n}\n/**\n * @param {?} instance\n * @param {?} functionName\n * @return {?}\n */\nfunction isFunction(instance, functionName) {\n    return (instance &&\n        functionName in instance &&\n        typeof instance[functionName] === 'function');\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/effects/src/tokens.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst _ROOT_EFFECTS_GUARD = new InjectionToken('@ngrx/effects Internal Root Guard');\n/** @type {?} */\nconst IMMEDIATE_EFFECTS = new InjectionToken('ngrx/effects: Immediate Effects');\n/** @type {?} */\nconst ROOT_EFFECTS = new InjectionToken('ngrx/effects: Root Effects');\n/** @type {?} */\nconst FEATURE_EFFECTS = new InjectionToken('ngrx/effects: Feature Effects');\n/** @type {?} */\nconst EFFECTS_ERROR_HANDLER = new InjectionToken('ngrx/effects: Effects Error Handler');\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/effects/src/effect_sources.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass EffectSources extends Subject {\n    /**\n     * @param {?} errorHandler\n     * @param {?} effectsErrorHandler\n     */\n    constructor(errorHandler, effectsErrorHandler) {\n        super();\n        this.errorHandler = errorHandler;\n        this.effectsErrorHandler = effectsErrorHandler;\n    }\n    /**\n     * @param {?} effectSourceInstance\n     * @return {?}\n     */\n    addEffects(effectSourceInstance) {\n        this.next(effectSourceInstance);\n    }\n    /**\n     * \\@internal\n     * @return {?}\n     */\n    toActions() {\n        return this.pipe(groupBy(getSourceForInstance), mergeMap((/**\n         * @param {?} source$\n         * @return {?}\n         */\n        source$ => {\n            return source$.pipe(groupBy(effectsInstance));\n        })), mergeMap((/**\n         * @param {?} source$\n         * @return {?}\n         */\n        source$ => {\n            /** @type {?} */\n            const effect$ = source$.pipe(exhaustMap((/**\n             * @param {?} sourceInstance\n             * @return {?}\n             */\n            sourceInstance => {\n                return resolveEffectSource(this.errorHandler, this.effectsErrorHandler)(sourceInstance);\n            })), map((/**\n             * @param {?} output\n             * @return {?}\n             */\n            output => {\n                reportInvalidActions(output, this.errorHandler);\n                return output.notification;\n            })), filter((/**\n             * @param {?} notification\n             * @return {?}\n             */\n            (notification) => notification.kind === 'N')), dematerialize());\n            // start the stream with an INIT action\n            // do this only for the first Effect instance\n            /** @type {?} */\n            const init$ = source$.pipe(take(1), filter(isOnInitEffects), map((/**\n             * @param {?} instance\n             * @return {?}\n             */\n            instance => instance.ngrxOnInitEffects())));\n            return merge(effect$, init$);\n        })));\n    }\n}\nEffectSources.decorators = [\n    { type: Injectable }\n];\n/** @nocollapse */\nEffectSources.ctorParameters = () => [\n    { type: ErrorHandler },\n    { type: undefined, decorators: [{ type: Inject, args: [EFFECTS_ERROR_HANDLER,] }] }\n];\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    EffectSources.prototype.errorHandler;\n    /**\n     * @type {?}\n     * @private\n     */\n    EffectSources.prototype.effectsErrorHandler;\n}\n/**\n * @param {?} sourceInstance\n * @return {?}\n */\nfunction effectsInstance(sourceInstance) {\n    if (isOnIdentifyEffects(sourceInstance)) {\n        return sourceInstance.ngrxOnIdentifyEffects();\n    }\n    return '';\n}\n/**\n * @param {?} errorHandler\n * @param {?} effectsErrorHandler\n * @return {?}\n */\nfunction resolveEffectSource(errorHandler, effectsErrorHandler) {\n    return (/**\n     * @param {?} sourceInstance\n     * @return {?}\n     */\n    sourceInstance => {\n        /** @type {?} */\n        const mergedEffects$ = mergeEffects(sourceInstance, errorHandler, effectsErrorHandler);\n        if (isOnRunEffects(sourceInstance)) {\n            return sourceInstance.ngrxOnRunEffects(mergedEffects$);\n        }\n        return mergedEffects$;\n    });\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/effects/src/effects_runner.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass EffectsRunner {\n    /**\n     * @param {?} effectSources\n     * @param {?} store\n     */\n    constructor(effectSources, store) {\n        this.effectSources = effectSources;\n        this.store = store;\n        this.effectsSubscription = null;\n    }\n    /**\n     * @return {?}\n     */\n    start() {\n        if (!this.effectsSubscription) {\n            this.effectsSubscription = this.effectSources\n                .toActions()\n                .subscribe(this.store);\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        if (this.effectsSubscription) {\n            this.effectsSubscription.unsubscribe();\n            this.effectsSubscription = null;\n        }\n    }\n}\nEffectsRunner.decorators = [\n    { type: Injectable }\n];\n/** @nocollapse */\nEffectsRunner.ctorParameters = () => [\n    { type: EffectSources },\n    { type: Store }\n];\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    EffectsRunner.prototype.effectsSubscription;\n    /**\n     * @type {?}\n     * @private\n     */\n    EffectsRunner.prototype.effectSources;\n    /**\n     * @type {?}\n     * @private\n     */\n    EffectsRunner.prototype.store;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/effects/src/effects_root_module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst ROOT_EFFECTS_INIT = '@ngrx/effects/init';\n/** @type {?} */\nconst rootEffectsInit = createAction(ROOT_EFFECTS_INIT);\nclass EffectsRootModule {\n    /**\n     * @param {?} sources\n     * @param {?} runner\n     * @param {?} store\n     * @param {?} rootEffects\n     * @param {?} storeRootModule\n     * @param {?} storeFeatureModule\n     * @param {?} guard\n     */\n    constructor(sources, runner, store, rootEffects, storeRootModule, storeFeatureModule, guard) {\n        this.sources = sources;\n        runner.start();\n        rootEffects.forEach((/**\n         * @param {?} effectSourceInstance\n         * @return {?}\n         */\n        effectSourceInstance => sources.addEffects(effectSourceInstance)));\n        store.dispatch({ type: ROOT_EFFECTS_INIT });\n    }\n    /**\n     * @param {?} effectSourceInstance\n     * @return {?}\n     */\n    addEffects(effectSourceInstance) {\n        this.sources.addEffects(effectSourceInstance);\n    }\n}\nEffectsRootModule.decorators = [\n    { type: NgModule, args: [{},] }\n];\n/** @nocollapse */\nEffectsRootModule.ctorParameters = () => [\n    { type: EffectSources },\n    { type: EffectsRunner },\n    { type: Store },\n    { type: Array, decorators: [{ type: Inject, args: [ROOT_EFFECTS,] }] },\n    { type: StoreRootModule, decorators: [{ type: Optional }] },\n    { type: StoreFeatureModule, decorators: [{ type: Optional }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [_ROOT_EFFECTS_GUARD,] }] }\n];\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    EffectsRootModule.prototype.sources;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/effects/src/effects_feature_module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass EffectsFeatureModule {\n    /**\n     * @param {?} root\n     * @param {?} effectSourceGroups\n     * @param {?} storeRootModule\n     * @param {?} storeFeatureModule\n     */\n    constructor(root, effectSourceGroups, storeRootModule, storeFeatureModule) {\n        effectSourceGroups.forEach((/**\n         * @param {?} group\n         * @return {?}\n         */\n        group => group.forEach((/**\n         * @param {?} effectSourceInstance\n         * @return {?}\n         */\n        effectSourceInstance => root.addEffects(effectSourceInstance)))));\n    }\n}\nEffectsFeatureModule.decorators = [\n    { type: NgModule, args: [{},] }\n];\n/** @nocollapse */\nEffectsFeatureModule.ctorParameters = () => [\n    { type: EffectsRootModule },\n    { type: Array, decorators: [{ type: Inject, args: [FEATURE_EFFECTS,] }] },\n    { type: StoreRootModule, decorators: [{ type: Optional }] },\n    { type: StoreFeatureModule, decorators: [{ type: Optional }] }\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/effects/src/effects_module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass EffectsModule {\n    /**\n     * @param {?} featureEffects\n     * @return {?}\n     */\n    static forFeature(featureEffects) {\n        return {\n            ngModule: EffectsFeatureModule,\n            providers: [\n                featureEffects,\n                {\n                    provide: FEATURE_EFFECTS,\n                    multi: true,\n                    deps: featureEffects,\n                    useFactory: createSourceInstances,\n                },\n            ],\n        };\n    }\n    /**\n     * @param {?} rootEffects\n     * @return {?}\n     */\n    static forRoot(rootEffects) {\n        return {\n            ngModule: EffectsRootModule,\n            providers: [\n                {\n                    provide: _ROOT_EFFECTS_GUARD,\n                    useFactory: _provideForRootGuard,\n                    deps: [[EffectsRunner, new Optional(), new SkipSelf()]],\n                },\n                {\n                    provide: EFFECTS_ERROR_HANDLER,\n                    useValue: defaultEffectsErrorHandler,\n                },\n                EffectsRunner,\n                EffectSources,\n                Actions,\n                rootEffects,\n                {\n                    provide: ROOT_EFFECTS,\n                    deps: rootEffects,\n                    useFactory: createSourceInstances,\n                },\n            ],\n        };\n    }\n}\nEffectsModule.decorators = [\n    { type: NgModule, args: [{},] }\n];\n/**\n * @param {...?} instances\n * @return {?}\n */\nfunction createSourceInstances(...instances) {\n    return instances;\n}\n/**\n * @param {?} runner\n * @return {?}\n */\nfunction _provideForRootGuard(runner) {\n    if (runner) {\n        throw new TypeError(`EffectsModule.forRoot() called twice. Feature modules should use EffectsModule.forFeature() instead.`);\n    }\n    return 'guarded';\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/effects/src/act.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Represents config with named paratemeters for act\n * @record\n * @template Input, OutputAction, ErrorAction, CompleteAction, UnsubscribeAction\n */\nfunction ActConfig() { }\nif (false) {\n    /** @type {?} */\n    ActConfig.prototype.project;\n    /** @type {?} */\n    ActConfig.prototype.error;\n    /** @type {?|undefined} */\n    ActConfig.prototype.complete;\n    /** @type {?|undefined} */\n    ActConfig.prototype.operator;\n    /** @type {?|undefined} */\n    ActConfig.prototype.unsubscribe;\n}\n/**\n * @template Input, OutputAction, ErrorAction, CompleteAction, UnsubscribeAction\n * @param {?} configOrProject\n * @param {?=} errorFn\n * @return {?}\n */\nfunction act(\n/** Allow to take either config object or project/error functions */\nconfigOrProject, errorFn) {\n    const { project, error, complete, operator, unsubscribe } = typeof configOrProject === 'function'\n        ? {\n            project: configOrProject,\n            error: (/** @type {?} */ (errorFn)),\n            operator: concatMap,\n            complete: undefined,\n            unsubscribe: undefined,\n        }\n        : Object.assign(Object.assign({}, configOrProject), { operator: configOrProject.operator || concatMap });\n    return (/**\n     * @param {?} source\n     * @return {?}\n     */\n    source => defer((/**\n     * @return {?}\n     */\n    () => {\n        /** @type {?} */\n        const subject = new Subject();\n        return merge(source.pipe(operator((/**\n         * @param {?} input\n         * @param {?} index\n         * @return {?}\n         */\n        (input, index) => defer((/**\n         * @return {?}\n         */\n        () => {\n            /** @type {?} */\n            let completed = false;\n            /** @type {?} */\n            let errored = false;\n            /** @type {?} */\n            let projectedCount = 0;\n            return project(input, index).pipe(materialize(), map((/**\n             * @param {?} notification\n             * @return {?}\n             */\n            (notification) => {\n                switch (notification.kind) {\n                    case 'E':\n                        errored = true;\n                        return new Notification((/** @type {?} */ (\n                        // TODO: remove any in RxJS 6.5\n                        'N')), error(notification.error, input));\n                    case 'C':\n                        completed = true;\n                        return complete\n                            ? new Notification((/** @type {?} */ (\n                            // TODO: remove any in RxJS 6.5\n                            'N')), complete(projectedCount, input))\n                            : undefined;\n                    default:\n                        ++projectedCount;\n                        return notification;\n                }\n            })), filter((/**\n             * @param {?} n\n             * @return {?}\n             */\n            (n) => n != null)), dematerialize(), finalize((/**\n             * @return {?}\n             */\n            () => {\n                if (!completed && !errored && unsubscribe) {\n                    subject.next(unsubscribe(projectedCount, input));\n                }\n            })));\n        }))))), subject);\n    })));\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/effects/src/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/effects/public_api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/effects/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Actions, EFFECTS_ERROR_HANDLER, Effect, EffectSources, EffectsFeatureModule, EffectsModule, EffectsRootModule, EffectsRunner, ROOT_EFFECTS_INIT, act, createEffect, defaultEffectsErrorHandler, getEffectsMetadata, mergeEffects, ofType, rootEffectsInit, getSourceMetadata as ɵngrx_modules_effects_effects_a, createSourceInstances as ɵngrx_modules_effects_effects_b, _provideForRootGuard as ɵngrx_modules_effects_effects_c, _ROOT_EFFECTS_GUARD as ɵngrx_modules_effects_effects_d, ROOT_EFFECTS as ɵngrx_modules_effects_effects_e, FEATURE_EFFECTS as ɵngrx_modules_effects_effects_f };\n"]}